# Copyright 2001, 2002 Dave Abrahams
# Copyright 2003 Douglas Gregor
# Copyright 2003 Rene Rivera
# Copyright 2002, 2003, 2004, 2005 Vladimir Prus
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE.txt or copy at
# https://www.bfgroup.xyz/b2/LICENSE.txt)


#   Returns a list of the following substrings:
#   1) from beginning till the first occurrence of 'separator' or till the end,
#   2) between each occurrence of 'separator' and the next occurrence,
#   3) from the last occurrence of 'separator' till the end.
#   If no separator is present, the result will contain only one element.
#
# rule split ( string separator )


# Returns the concatenated results of Applying regex.split to every element of
# the list using the separator pattern.
#
# rule split-list ( list * : separator )


# Match string against pattern, and return the elements indicated by indices.
#
# rule match ( pattern : string : indices * )


# Matches all elements of 'list' against the 'pattern' and returns a list of
# elements indicated by indices of all successful matches. If 'indices' is
# omitted returns a list of first parenthesised groups of all successful
# matches.
#
# rule transform ( list * : pattern : indices * )


# Escapes all of the characters in symbols using the escape symbol escape-symbol
# for the given string, and returns the escaped string.
#
# rule escape ( string : symbols : escape-symbol )


# Replaces occurrences of a match string in a given string and returns the new
# string. The match string can be a regex expression.
#
# rule replace (
#     string  # The string to modify.
#     match  # The characters to replace.
#     replacement  # The string to replace with.
#     )


# Replaces occurrences of a match string in a given list of strings and returns
# a list of new strings. The match string can be a regex expression.
#
# list        - the list of strings to modify.
# match       - the search expression.
# replacement - the string to replace with.
#
# rule replace-list ( list * : match : replacement )


rule __test__ ( )
{
    import assert ;

    assert.result a b c : split "a/b/c" / ;
    assert.result "" a b c : split "/a/b/c" / ;
    assert.result "" "" a b c : split "//a/b/c" / ;
    assert.result "" a "" b c : split "/a//b/c" / ;
    assert.result "" a "" b c "" : split "/a//b/c/" / ;
    assert.result "" a "" b c "" "" : split "/a//b/c//" / ;
    # assert.result "" a b c "" : split "abc" "" ;
    # assert.result "" "" : split "" "" ;
    assert.result "<x>y" "z" "<a>b" "c" "<d>e" "f" : split "<x>y\\z\\<a>b\\c\\<d>e\\f" "[\\/]" ;

    assert.result a b c "" a "" b c "" "" : split-list "a/b/c" "/a//b/c//" : / ;

    assert.result a c b d
        : match (.)(.)(.)(.) : abcd : 1 3 2 4 ;
    assert.result a b c d
        : match (.)(.)(.)(.) : abcd ;
    assert.result ababab cddc
        : match "((ab)*)([cd]+)" : abababcddc : 1 3 ;
    assert.result "a:"
        : match "(^.:)" : "a:/b" ;

    assert.result a.h c.h
        : transform <a.h> \"b.h\" <c.h> : <(.*)> ;

    assert.result a.h b.h c.h
        : transform <a.h> \"b.h\" <c.h> : "<([^>]*)>|\"([^\"]*)\"" : 1 2 ;

    assert.result "^<?xml version=\"1.0\"^>"
        : escape "<?xml version=\"1.0\">" : "&|()<>^" : "^" ;

    assert.result "<?xml version=\\\"1.0\\\">"
        : escape "<?xml version=\"1.0\">" : "\\\"" : "\\" ;

    assert.result "string&nbsp;string&nbsp;" : replace "string string " " " "&nbsp;" ;
    assert.result "&nbsp;string&nbsp;string" : replace " string string" " " "&nbsp;" ;
    assert.result "string&nbsp;&nbsp;string" : replace "string  string" " " "&nbsp;" ;
    assert.result "-" : replace "&" "&" "-" ;
    # assert.result "x" : replace "" "" "x" ;
    # assert.result "xax" : replace "a" "" "x" ;
    # assert.result "xaxbx" : replace "ab" "" "x" ;
    assert.result "a-b-c-d" : replace "a_b.c/d" "[_./]" "-" ;

    assert.result "-" "a-b" : replace-list "&" "a&b" : "&" : "-" ;
}
